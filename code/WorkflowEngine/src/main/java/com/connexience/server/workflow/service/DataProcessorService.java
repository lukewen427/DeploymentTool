/**
 * e-Science Central
 * Copyright (C) 2008-2013 School of Computing Science, Newcastle University
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation at:
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, 5th Floor, Boston, MA 02110-1301, USA.
 */
package com.connexience.server.workflow.service;

import com.connexience.server.ConnexienceException;
import com.connexience.server.model.document.DocumentRecord;
import com.connexience.server.model.metadata.MetadataCollection;
import com.connexience.server.workflow.engine.*;
import com.connexience.server.workflow.engine.datatypes.*;
import com.connexience.server.workflow.api.*;
import com.connexience.server.model.workflow.notification.*;
import com.connexience.server.util.*;
import com.connexience.server.model.security.*;
import com.connexience.server.model.workflow.WorkflowDocument;
import com.connexience.server.model.workflow.WorkflowInvocationFolder;
import com.connexience.server.model.workflow.WorkflowParameterList;
import com.connexience.server.workflow.cloud.rmi.ExternalProcessStartNotifer;
import com.connexience.server.workflow.service.clients.DataProcessorDataSourceFileClient;
import com.connexience.server.workflow.util.ProcessMemoryMonitor;

import org.pipeline.core.drawing.*;
import org.pipeline.core.xmlstorage.XmlDataStore;
import org.pipeline.core.data.Data;
import org.pipeline.core.xmlstorage.io.XmlFileIO;
import org.pipeline.core.xmlstorage.replacement.StringPropertiesReplacer;

import java.io.*;
import java.rmi.RemoteException;
import java.util.*;
import org.pipeline.core.drawing.model.DefaultDrawingModel;

/**
 * This class defines a data processor that takes in one or more TransferData
 * objects and returns one or more result TransferData objects. It should be implemented
 * by class that provide data processing facilities.
 * @author hugo
 */
public abstract class DataProcessorService {

    /** CallMessage thread local object */
    private DataProcessorCallMessage callMessage;

    /** Security ticket from call message */
    private Ticket ticket;
            
    /** Response message destination */
    private DataProcessorResponseMessageHandler responder;

    /** Captured output text */
    private String outputData = "";

    /** Name of the XML resource if there is one */
    private String xmlDefinitionResource = "";

    /** Registered name in the service endpoint */
    private String registeredName = "";

    /** Maximum length of output data to capture */
    private int outputDataLimit = 4096;

    /** Streaming chunk size */
    private int chunkSize = 1000;

    /** Input data transfer objects */
    private Hashtable<String, InputTransferDataHolder> inputDataTransferObjects = new Hashtable<>();

    /** Output data transfer objects */
    private Hashtable<String, OutputTransferDataHolder> outputDataTranferObjects = new Hashtable<>();

    /** Streamed input if there is one */
    private Vector<InputTransferDataHolder> streamedInputs = new Vector<>();

    /** Has this service been called yet. This is implied when the isStreamingFinished method is called */
    private boolean serviceCalled = false;

    /** Workflow lock created for any sub-workflows */
    private WorkflowLock lock = null;

    /** Has the lock been used */
    private boolean lockUsed = false;
    
    /** Global properties that workflow services can read and write to */
    private XmlDataStore globalProperties = new XmlDataStore();
    
    /** Provenance data to send with API calls */
    private XmlDataStore provenanceData = null;
    
    /** Drawing data if required */
    private DefaultDrawingModel drawing = null;
    
    /** API Connection object */
    private APIBroker apiBroker;
    
    /** Extra APIs */
    private ArrayList<APIBroker> additionalApis = new ArrayList<>();
    
    /** HashMap of input data sets. This is null until created the first time. The
     * purpose of this is so that code can get inputs multiple times without going
     * through the chunking processes. It was added to support the GnuplotEngine
     * which is meant to allow multiple plots to be generated by a block */
    private HashMap<String, Data> inputDataSetMap = null;
    
    /** Set this service to use a streaming chunk size */
    public void streamInChunksOf(int chunkSize) {
        this.chunkSize = chunkSize;
    }

    /** Get the API link */
    public final APIBroker createApiLink() throws ConnexienceException {
        if(apiBroker==null){
            try {
                APIBrokerFactory factory = (APIBrokerFactory)RegistryUtil.lookup("localhost", "APIBroker");
                if(provenanceData!=null){
                    apiBroker = factory.createApi(ticket, callMessage.getInvocationId(), provenanceData);
                } else {
                    apiBroker = factory.createApi(ticket, callMessage.getInvocationId());
                }
                return apiBroker;
            } catch (Exception e){
                throw new ConnexienceException("Error creating API link: " + e.getMessage(), e);
            }
        } else {
            return apiBroker;
        }
    }
    
    /** Create an API link as another user */
    public final APIBroker createAdditionalApiLink(User user) throws ConnexienceException {
        try {
            APIBrokerFactory factory = (APIBrokerFactory)RegistryUtil.lookup("localhost", "APIBroker");
            APIBroker api = factory.createApi(user, callMessage.getInvocationId());
            additionalApis.add(api);
            return api;
        } catch (Exception e){
            throw new ConnexienceException("Error creating API link: " + e.getMessage(), e);
        }
    }
    
    /** Release an additional API link */
    public final void releaseAdditionalApiLink(APIBroker additionalApi) throws ConnexienceException, RemoteException {
        if(additionalApis.contains(additionalApi)){
            additionalApis.remove(additionalApi);
            additionalApi.release();
        }
    }
    
    /** Notify the start of an external process */
    public void notifyExternalProcessStart(Process p) throws ConnexienceException {
        long pid = ProcessMemoryMonitor.extractPid(p);
        if(pid!=-1){
            try {
                ExternalProcessStartNotifer notifier = (ExternalProcessStartNotifer)RegistryUtil.lookup("localhost", "ProcessNotifier");
                notifier.processStarted(getCallMessage().getInvocationId(), getCallMessage().getContextId(), pid);
            } catch (Exception e){
                throw new ConnexienceException("Error notifying external process start: " + e.getMessage(), e);
            }
        }
    }
    
    /** Does this processor contain a streamed input */
    public boolean containsStreamedInput() {
        if (streamedInputs.size() > 0) {
            return true;
        } else {
            return false;
        }
    }

    /** Set the provenance data */
    public void setProvenanceData(XmlDataStore provenanceData) {
        this.provenanceData = provenanceData;
    }

    /** Get the provenance data */
    public XmlDataStore getProvenanceData() {
        return provenanceData;
    }

    /** Get the call properties */
    public XmlDataStore getProperties() {
        return getCallMessage().getProperties();
    }

    /** Get the call properties. This method is provided to help source
     * code compatibility with the existing blocks */
    public XmlDataStore getEditableProperties() {
        return getCallMessage().getProperties();
    }

    /** Set the the command output data */
    public void setCommandOutputData(String outputData) {
        this.outputData = outputData;
    }

    /** Get the command output data */
    public String getCommandOutputData() {
        return outputData;
    }

    /** Get the output data limit */
    public int getOutputDataLimit() {
        return outputDataLimit;
    }

    /** Set the output data limit */
    public void setOutputDataLimit(int outputDataLimit) {
        this.outputDataLimit = outputDataLimit;
    }

    /** Set the registered name */
    public void setRegisteredName(String registeredName) {
        this.registeredName = registeredName;
    }

    /** Get the registered name */
    public String getRegisteredName() {
        return registeredName;
    }

    /** Get / load the drawing data for this workflow */
    public DefaultDrawingModel getDrawing() throws Exception {
        if(drawing!=null){
            return drawing;
        } else {
            File invocationDataFile = new File(getWorkingDirectory(), "_invocationData.xml");
            if(invocationDataFile.exists()){
                try {
                    XmlFileIO reader = new XmlFileIO(invocationDataFile);
                    XmlDataStore invocationData = reader.readFile();
                    XmlDataStore drawingData = invocationData.xmlDataStoreValue("DrawingData");
                    drawing = new DefaultDrawingModel();
                    drawing.recreateObject(drawingData);
                    return drawing;
                } catch (Exception e){
                    drawing = null;
                    throw new Exception("Cannot load drawing data from invocation directory");
                }
            } else {
                throw new Exception("Cannot find drawing data file in invocation directory");
            }
        }
    }
    /** Set the call message */
    public void setCallMessage(DataProcessorCallMessage callMessage) {
        this.callMessage = callMessage;
    }
    
    /** Set the ticket */
    public void setTicket(Ticket ticket){ 
        this.ticket = ticket;
    }
    
    /** Get the ticket */
    public Ticket getTicket(){
        return ticket;
    }

    /** Get the call message */
    public DataProcessorCallMessage getCallMessage() {
        return callMessage;
    }

    /** Set the response message destination */
    public void setResponseDestination(DataProcessorResponseMessageHandler responder) {
        this.responder = responder;
    }

    /** Get the response message destination */
    public DataProcessorResponseMessageHandler getResponseDestination() {
        return responder;
    }

    /** Create a response message. Sends an OK message */
    public void sendResponseMessage() throws DataProcessorException {
        DataProcessorCallMessage call = getCallMessage();
        DataProcessorResponseMessage message = new DataProcessorResponseMessage(call.getInvocationId(), call.getContextId());
        message.setStatus(DataProcessorResponseMessage.SERVICE_EXECUTION_OK);
        message.setStatusMessage("");
        message.setCommandOutput(getCommandOutputData());

        // Set lock status
        if(lockUsed && lock!=null){
            message.setWaitingForLock(true);
            message.setLockId(lock.getId());
        } else {
            message.setWaitingForLock(false);
            message.setLockId(0);
        }

        getResponseDestination().sendResponseMessage(message);
    }

    /** Send a response message containing an error */
    public void sendErrorResponseMessage(String statusMessage) {
        try {
            DataProcessorCallMessage call = getCallMessage();
            DataProcessorResponseMessage message = new DataProcessorResponseMessage(call.getInvocationId(), call.getContextId());
            message.setStatus(DataProcessorResponseMessage.SERVICE_EXECUTION_ERROR);
            message.setStatusMessage(statusMessage);
            getResponseDestination().sendResponseMessage(message);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /** Is an input connected */
    public boolean isInputConnected(String inputName) throws DataProcessorException {
        if (inputDataTransferObjects.containsKey(inputName)) {
            return inputDataTransferObjects.get(inputName).isConnected();
        } else {
            throw new DataProcessorException("Cannot find input: " + inputName);
        }        
    }

    /** Is an output connected. This method has to load the drawing data from
    * the invocation directory because a service has no idea if there is anything
    * about to read its output files */
    public boolean isOutputConnected(String outputName) throws DataProcessorException {
        if(outputDataTranferObjects.containsKey(outputName)){
            try {
                DefaultDrawingModel d = getDrawing();
                if(d!=null){
                    BlockModel block = d.getBlock(callMessage.getContextId());
                    if(block!=null){
                        if(block.getOutput(outputName)!=null){
                            if(block.getOutput(outputName).connections().hasMoreElements()){
                                return true;
                            } else {
                                return false;
                            }
                        } else {
                            throw new DataProcessorException("Block does not contain the correct output port in drawing data");
                        }
                    } else {
                        throw new DataProcessorException("Cannot find corresponding block in drawing data");
                    }
                } else {
                    throw new DataProcessorException("No drawing");
                }
            } catch (Exception e){
                throw new DataProcessorException("Cannot access drawing data: " + e.getMessage(), e);
            }
                    
            
        } else {
            throw new DataProcessorException("Cannot find output: " + outputName);
        }
        
        
    }
    
    /** Get an input data transfer object */
    public TransferData getInputData(String inputName) throws DataProcessorException {
        if (inputDataTransferObjects.containsKey(inputName)) {
            return inputDataTransferObjects.get(inputName).getTransferData();
        } else {
            throw new DataProcessorException("Cannot find input: " + inputName);
        }
    }

    /** Get the metadata for an input */
    public MetadataCollection getInputMetadata(String inputName) throws DataProcessorException {
        if (inputDataTransferObjects.containsKey(inputName)) {
            return inputDataTransferObjects.get(inputName).getMetadata();
        } else {
            throw new DataProcessorException("Cannot find input: " + inputName);
        }        
    }
    
    /** Send some metadata to an output */
    public void setOutputMetadata(String outputName, MetadataCollection metadata) throws DataProcessorException {
        if (outputDataTranferObjects.containsKey(outputName)) {
            if(outputDataTranferObjects.get(outputName).getMetadata()==null){
                outputDataTranferObjects.get(outputName).setMetadata(metadata);
            } else {
                outputDataTranferObjects.get(outputName).getMetadata().merge(metadata, MetadataCollection.DuplicatePolicy.DUPLICATES_OVERWRITTEN);
            }
        } else {
            if (getEditableProperties().booleanValue("ErrorsForNonExistentPorts", true)) {
                throw new DataProcessorException("Cannot find output: " + outputName);
            }
        }     
    }
    
    /** Attach a piece of metadata to all of the outputs */
    public void addMetadataToAllOutputs(MetadataCollection metadata) throws DataProcessorException {
        for(String s : outputDataTranferObjects.keySet()){
            setOutputMetadata(s, metadata);
        }
    }
    
    /** Send some output data to one of the return connections */
    public void setOutputData(String outputName, TransferData data) throws DataProcessorException {
        if (!(data instanceof StreamableTransferData)) {
            if (outputDataTranferObjects.containsKey(outputName)) {
                outputDataTranferObjects.get(outputName).setDataObject(data);
            } else {
              if(getEditableProperties().booleanValue("ErrorsForNonExistentPorts", true))
              {
                throw new DataProcessorException("Cannot find output: " + outputName);
              }
            }
        } else {
            if (getEditableProperties().booleanValue("ErrorsForNonExistentPorts", true)) {
                throw new DataProcessorException("Cannot perform setOutputData on a streaming connection");
            }
        }
    }

    /** Pass a data set to an output */
    public void setOutputDataSet(String outputName, Data data) throws DataProcessorException {
        if (outputDataTranferObjects.containsKey(outputName)) {
            OutputTransferDataHolder holder = outputDataTranferObjects.get(outputName);
            if (holder.isStreamingObject() && holder.getTransferData() instanceof DataWrapper) {
                try {
                    ((DataWrapper) holder.getTransferData()).writeChunk(data);
                } catch (Exception e) {
                  if(getEditableProperties().booleanValue("ErrorsForNonExistentPorts", true))
                  {
                    throw new DataProcessorException("Error writing data block to output: " + outputName + ": " + e.getMessage());
                  }
                }
            }
        } else {
            if (getEditableProperties().booleanValue("ErrorsForNonExistentPorts", true)) {
                throw new DataProcessorException("Cannot find output: " + outputName);
            }
        }
    }

    
    /** Populates the map of all input data sets.
     * 
     * @throws DataProcessorException 
     */
    public void populateInputDataSetMap() throws DataProcessorException {
      this.getInputDataSetMap();
        
    }
    
    
    /** Gets all input data sets as a map.
     * 
     * NB Despite the name, this is not just a 'getter', calling this method affects the
     * internal state of this DataProcessorService object. I.e. if the instance variable
     * inputDataSeMap is null, calling this method will populate it. (dps - 7/2/14)
     * 
     * @return A HashMap of all input data sets
     * @throws DataProcessorException 
     */
    public HashMap<String, Data> getInputDataSetMap() throws DataProcessorException {
        if(inputDataSetMap!=null){
            return inputDataSetMap;
            
        } else {
            String[] names = getCallMessage().getDataSources();        
            HashMap<String, Data> results = new HashMap<>();
            for (int i=0;i<names.length;i++) {
                if(getCallMessage().getDataSourceTypes()[i].equals("data-wrapper")){
                    results.put(names[i], getInputDataSet(names[i]));
                }        
            }
            inputDataSetMap = results;
            return inputDataSetMap;
        }
    }
    
    /** Get some input data as a Data set object */
    public Data getInputDataSet(String inputName) throws DataProcessorException {
        // Throw and error if we have called getInputDataSetMap because this will
        // mess up streaming.
        if(inputDataSetMap!=null){
            // Have to use the input data set map
            return inputDataSetMap.get(inputName);
            
        } else {
            TransferData holder = getInputData(inputName);
            if (holder instanceof DataWrapper) {
                DataWrapper dataWrapper = (DataWrapper) holder;
                try {
                    // Check streaming mode
                    if (getCallMessage().getStreamMode().equals(DataProcessorServiceDefinition.STREAM_SQEUENTIAL_MODE)) {
                        // Check to see that the other inputs defined before this one have finished
                        boolean okToStream = true;
                        InputTransferDataHolder inp = inputDataTransferObjects.get(inputName);
                        int pos = streamedInputs.indexOf(inp);
                        if (pos > 0) {
                            // Not the first input, check that everything up to this point
                            // is ok to stream
                            for (int i = 0; i < pos; i++) {
                                if (!streamedInputs.get(i).isFinished()) {
                                    okToStream = false;
                                }
                            }
                        }

                        if (okToStream) {
                            Data data = dataWrapper.readChunk();
                            return data;
                        } else {
                            // Not ready to stream - return null
                            return null;

                        }

                    } else {
                        // Send data as is
                        Data data = dataWrapper.readChunk();
                        return data;
                    }

                } catch (Exception e) {
                    throw new DataProcessorException("Error reading data block: " + e.getMessage());
                }
            } else {
                throw new DataProcessorException("Input: " + inputName + " is not a data connection");
            }
        }
    }

    /** Get an empty data set for an input with the correct layout of rows */
    public Data getEmptyInputDataSet(String inputName) throws DataProcessorException {
        if (inputDataTransferObjects.containsKey(inputName)) {
            InputTransferDataHolder holder = inputDataTransferObjects.get(inputName);
            if (holder.getTransferData() instanceof DataWrapper) {
                try {
                    return ((DataWrapper) holder.getTransferData()).getEmptyData();
                } catch (DrawingException de) {
                    throw new DataProcessorException("Error creating empty data set: " + de.getMessage());
                }
            } else {
                throw new DataProcessorException("Cannot create empty data from a non-data connection");
            }
        } else {
            throw new DataProcessorException("Input: " + inputName + " does not exist");
        }
    }

    /** Set the resource name of the Xml service definition */
    public void setXmlDefinitionResource(String xmlDefinitionResource) {
        this.xmlDefinitionResource = xmlDefinitionResource;
    }

    /** Get the service definition object */
    public String getServiceXml() {
        try {
            InputStream stream = getClass().getResourceAsStream(xmlDefinitionResource);
            ByteArrayOutputStream bufferStream = new ByteArrayOutputStream();
            byte[] buffer = new byte[1024];
            int len;
            while ((len = stream.read(buffer)) != -1) {
                bufferStream.write(buffer, 0, len);
            }

            return new String(bufferStream.toByteArray());

        } catch (Exception e) {
            System.out.println("Cannot locate service definition: " + e.getMessage());
            return null;
        }
    }

    /** Get the temporary storage directory of the data source */
    public File getWorkingDirectory() throws DataProcessorException {
        DataProcessorCallMessage message = getCallMessage();
        DataProcessorDataSource source = createSourceClient(message);
        if (source.allowsFileSystemAccess()) {
            return new File(source.getStorageDirectory(message.getInvocationId()));
        } else {
            throw new DataProcessorException("Data transport does not allow file system access");
        }
    }


    /** Close all of the service IOs */
    public void closeIOs() {
        Enumeration<InputTransferDataHolder> inputs = inputDataTransferObjects.elements();
        InputTransferDataHolder input;
        OutputTransferDataHolder output;

        while (inputs.hasMoreElements()) {
            input = inputs.nextElement();
            try {
                input.close();
            } catch (Exception e) {
                System.out.println("Could not close input: " + input);
            }
        }

        Enumeration<OutputTransferDataHolder> outputs = outputDataTranferObjects.elements();
        while (outputs.hasMoreElements()) {
            output = outputs.nextElement();
            try {
                output.close();
            } catch (Exception e) {
                System.out.println("Could not close output: " + output);
            }
        }
    }

    /** Return the total number of bytes to be streamed for inputs
     * that support this information */
    public long getTotalBytesToStream() {
        if (streamedInputs.size() > 0) {
            InputTransferDataHolder holder;
            StreamableTransferData transferData;
            long total = 0;

            for (int i = 0; i < streamedInputs.size(); i++) {
                holder = streamedInputs.get(i);
                if (holder.getTransferData() instanceof StreamableTransferData) {
                    transferData = (StreamableTransferData) holder.getTransferData();
                    if (transferData.isTotalBytesKnown()) {
                        total = total + transferData.getTotalBytesToRead();

                    }
                }
            }
            return total;
        } else {
            return 0;
        }
    }

    /** Return the total number of bytes streamed */
    public long getTotalBytesStreamed() {
        if (streamedInputs.size() > 0) {
            InputTransferDataHolder holder;
            StreamableTransferData transferData;
            long total = 0;

            for (int i = 0; i < streamedInputs.size(); i++) {
                holder = streamedInputs.get(i);
                if (holder.getTransferData() instanceof StreamableTransferData) {
                    transferData = (StreamableTransferData) holder.getTransferData();
                    if (transferData.isTotalBytesKnown()) {
                        total = total + transferData.getActualBytesRead();
                    }
                }
            }
            return total;
        } else {
            return 0;
        }
    }
    
    /** Get the global properties object */
    public XmlDataStore getGlobalProperties(){
        return globalProperties;
    }
    
    /** Load the global properties into this block */
    public void loadGlobalProperties() throws DataProcessorException {
        File dir = getWorkingDirectory();
        File globalPropertiesFile = new File(dir, "_globalProperties.xml");
        if(globalPropertiesFile.exists()){
            try {
                XmlFileIO reader = new XmlFileIO(globalPropertiesFile);
                globalProperties = reader.readFile();
            } catch (Exception e){
                throw new DataProcessorException("Error loading global properties: " + e.getMessage(), e);
            }
        } else {
            globalProperties = new XmlDataStore("GlobalProperties");
        }
    }
    
    public void saveGlobalProperties() throws DataProcessorException {
        File dir = getWorkingDirectory();
        File globalPropertiesFile = new File(dir, "_globalProperties.xml");
        try {
            XmlFileIO writer = new XmlFileIO(globalProperties);
            writer.writeFile(globalPropertiesFile);
        } catch (Exception e){
            throw new DataProcessorException("Error loading global properties: " + e.getMessage(), e);
        }
    }

    /** Initialise all of the inputs and outputs. This opens the files
     * ready for reading / writing and sets any chunking requirements */
    public void initialiseIOs() throws DataProcessorException {
        // Create a data source client
        inputDataTransferObjects.clear();
        outputDataTranferObjects.clear();
        DataProcessorCallMessage message = getCallMessage();
        DataProcessorDataSource source = createSourceClient(message);
        streamedInputs.clear();

        // Create the inputs
        String dataType;
        String inputName;
        String outputName;
        int sourceIndex;

        // Create a data store to contain the overridden properties
        XmlDataStore propertyOverrides = new XmlDataStore();
        
        for (int i = 0; i < message.getDataSources().length; i++) {
            inputName = message.getDataSources()[i];
            dataType = message.getDataSourceType(inputName);

            if (dataType == null) {
                throw new DataProcessorException("Cannot locate data type for input: " + inputName);
            }

            // Find the block that supplies data to this input
            sourceIndex = message.getDataSourceIndex(inputName);
            if (sourceIndex != -1) {
                String linkedPort = message.getDataSourceConnections()[sourceIndex];
                String linkedContext = message.getDataSourceConnectionContexts()[sourceIndex];

                // Create the correct type of data client
                source = createSourceClient(message);

                if (source != null) {
                    InputTransferDataHolder holder;

                    // Is this the streaming connection
                    if (message.getDataSourceMode(inputName).equals(DataProcessorIODefinition.STREAMING_CONNECTION)) {
                        // Streaming input
                        holder = new InputTransferDataHolder(dataType, linkedPort, linkedContext, source, message.getInvocationId(), true, chunkSize);
                        streamedInputs.add(holder);
                    } else {
                        // Non-streaming input
                        holder = new InputTransferDataHolder(dataType, linkedPort, linkedContext, source, message.getInvocationId(), false, chunkSize);
                        
                        // If this is a properties input object, copy the properties into the property overrides store
                        if(holder.getTransferData() instanceof PropertiesWrapper){
                            try {
                                PropertiesWrapper props = (PropertiesWrapper)holder.getTransferData();
                                propertyOverrides.copyProperties(props.properties());
                            } catch (Exception e){
                                throw new DataProcessorException("Could not load properties from input: " + inputName, e);
                            }
                        }
                    }

                    inputDataTransferObjects.put(inputName, holder);
                } else {
                    throw new DataProcessorException("Could not create data access client");
                }
            } else {
                throw new DataProcessorException("Cannot locate input: " + inputName);
                // NOTES>>>
                // Currently creating input objects ready to be read.
                // Need to have a streaming definition in the message / service definition
                // For non-streaming inputs read immediately on instantiation
                // Need to check closing etc when there are exceptions
                // Chunk size etc set in message + system property for when to switch into chunking mode

            }
        }

        // Override / add any properties contained in the property overrides
        if(propertyOverrides.size()>0){
            try {
                StringPropertiesReplacer replacer = new StringPropertiesReplacer(message.getProperties(), propertyOverrides);
                message.getProperties().copyProperties(replacer.replace());
            } catch (Exception e){
                throw new DataProcessorException("Error copying properties into message properties: " + e.getMessage(), e);
            }
        }
        
        // Create the outputs
        for (int i = 0; i < message.getDataOutputs().length; i++) {
            outputName = message.getDataOutputs()[i];
            dataType = message.getDataOutputType(outputName);

            if (dataType == null) {
                throw new DataProcessorException("Cannot locate data type for output: " + outputName);
            }

            source = createSourceClient(message);
            if (source != null) {
                OutputTransferDataHolder holder = new OutputTransferDataHolder(dataType, outputName, message.getContextId(), source, message.getInvocationId());
                outputDataTranferObjects.put(outputName, holder);
            } else {
                throw new DataProcessorException("Could not create output data access client");
            }
        }
    }

    /** Is the streaming finished */
    public boolean isStreamingFinished() {
        if (streamedInputs.size() > 0) {
            for (int i = 0; i < streamedInputs.size(); i++) {
                // An input is still running, so return false
                if (!streamedInputs.get(i).isFinished()) {
                    return false;
                }
            }
            return true;

        } else {
            if (inputDataTransferObjects.size() > 0) {
                // Some inputs, although not streaming. Allow service to be called once
                if (serviceCalled) {
                    return true;
                } else {
                    serviceCalled = true;
                    return false;
                }

            } else {
                // If there are no inputs, allow the service to be called one time only
                if (serviceCalled) {
                    return true;
                } else {
                    // First time, always return false
                    serviceCalled = true;
                    return false;
                }
            }
        }

    }

    /** Create a temporary file in the invocation directory. Name is incorporated into the generated
     * file in an unspecified way. */
    public File createTempFile(String name) throws Exception {
        File workingDir = getWorkingDirectory();
        File tempFile = new File(workingDir, callMessage.getContextId() + "-" + name + ".tmp");
        return tempFile;
    }

    /** Execute the service. This will be called each time a chunk of data is processed.
     * A call to isStreaming() will determine if the service is actually streaming data. */
    public abstract void execute() throws Exception;

    /** This method is call when a service is about to be started. It is called once
     * regardless of whether or not the service is streaming data. */
    public void executionAboutToStart() throws Exception {
    }

    /** All of the data has been passed through the service. Services that need to
     * see all of the data should now set their outputs */
    public void allDataProcessed() throws Exception {

    }

    /** Pre-close tidyup. This method is called before the block process exists. It is used to setup any locks etc */
    public void preCloseTidyup() throws Exception {
        // If there is a lock and it hasn't been used, delete it
        if(lock!=null){
            if(lockUsed==false){
                createApiLink().removeWorkflowLock(lock.getId());
            } else {
                createApiLink().setWorkflowLockStatus(lock.getId(), WorkflowLock.LOCK_WAITING);
            }
        }
        
        // Release the API if there is one
        if(apiBroker!=null){
            System.out.println("Releasing API");
            apiBroker.release();
        }
        
        // Release extra APIs
        for(APIBroker api : additionalApis){
            try {
                System.out.println("Releasing additional API");
                api.release();
            } catch (Exception e){
                System.out.println("Error releasing additional API: " + e.getMessage());
            }
        }
    }

    /** Create a workflow lock for this service */
    public WorkflowLock createWorkflowLock() throws Exception {
        if (lock == null) {
            lock = createApiLink().createWorkflowLock(getCallMessage().getInvocationId(), getCallMessage().getContextId(), false, false);
            lockUsed = false;
            return lock;
        } else {
            throw new Exception("Services can only create a single workflow lock");
        }
    }

    /** Create a workflow lock with pause and allow error flags */
    public WorkflowLock createWorkflowLock(boolean allowFailedSubworkflows, boolean pauseOnFailures) throws Exception {
        if(lock==null){
            lock = createApiLink().createWorkflowLock(getCallMessage().getInvocationId(), getCallMessage().getContextId(), allowFailedSubworkflows, pauseOnFailures);
            lockUsed = false;
            return lock;
        } else {
            throw new Exception("Services can only create a single workflow lock");
        }
    }


    public void attachInvocationToLock(WorkflowInvocationFolder folder, WorkflowLock lock) throws Exception
    {
        if (lock == null) {
            throw new Exception("Missing workflow lock");
        }
        if (lock.getId() != this.lock.getId()) {
            throw new Exception("Invalid lock");
        }

        createApiLink().attachInvocationToLock(folder.getInvocationId(), lock.getId());
        lockUsed = true;
    }


    /** Execute a workflow and attach it to a lock */
    public WorkflowInvocationFolder executeWorkflowWithLock(WorkflowDocument workflow, WorkflowParameterList params, WorkflowLock wfLock, String folderName) throws Exception {

        if (this.lock != null) {
            if (wfLock.getId() == this.lock.getId()) {
                WorkflowInvocationFolder invocation = createApiLink().executeWorkflow(workflow, params, lock.getId(), folderName);
                lockUsed = true;
                return invocation;
            } else {
                throw new Exception("Wrong lock");
            }
        } else {
            throw new Exception("No lock created");
        }

    }

    /** Execute a workflow and attach it to a lock */
    public WorkflowInvocationFolder executeWorkflow(WorkflowDocument workflow, WorkflowParameterList params, String folderName) throws Exception {

        WorkflowInvocationFolder invocation = createApiLink().executeWorkflow(workflow, params, -1, folderName);
        return invocation;
    }
    
    public void persistDataToServer() throws Exception {
        try {
                WorkflowInvocationFolder inv = createApiLink().getWorkflowInvocation(callMessage.getInvocationId());

                for (String outputDataName : outputDataTranferObjects.keySet()) {
                    OutputTransferDataHolder transferHolder = outputDataTranferObjects.get(outputDataName);

                    if (transferHolder.getTransferTypeName().equals("file-wrapper")) {
                        //files are stored as a list of files in a file
                        String transferFilename = outputDataName + "-" + callMessage.getContextId() + ".dat";
                        BufferedReader input = new BufferedReader(new FileReader(new File(transferFilename)));
                        try {
                            String line;

                            //read each file referenced and upload
                            while ((line = input.readLine()) != null) {
                                File dataFile = new File(line);
                                DocumentRecord doc = new DocumentRecord();
                                doc.setName(dataFile.getName());
                                doc.setContainerId(inv.getId());
                                doc.setDescription("Data persisted from workflow invocation");
                                doc = createApiLink().saveDocument(inv, doc);
                                createApiLink().uploadFile(doc, dataFile);
                            }
                        } finally {
                            input.close();
                        }
                    } else if (transferHolder.getTransferTypeName().equals("data-wrapper")) {
                        //TODO: Fix as data is null at present - why?!
//              DataWrapper wrapper = (DataWrapper) transfer.getTransferData();
//              Data data = wrapper.readChunk();
//              CSVDataExporter exporter = new CSVDataExporter(data);
//              String filename = outputDataName + "_" + callMessage.getContextId() + "_transfer.csv";
//              exporter.writeFile(new File(filename));
//
//              IDocument doc = new InkspotDocument();
//              doc.setName(filename);
//              doc.setContainerId(inv.getId());
//              doc.setDescription("Data persisted from workflow invocation");
//              doc = apiLink.saveDocument(inv, doc);
//
//              apiLink.upload(doc, new FileInputStream(new File(filename)));
                    }
                }
            
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        }
    }

    private Collection<File> existingFiles = new TreeSet<>(new Comparator<File>() {

        @Override
        public int compare(File file, File file1) {
            return file.getName().compareTo(file1.getName());
        }
    });

    /**
     *  Get a list of new files in the directory since the last snapshot.  Does not include files that have been modified, only files that have been added.
     * @return A List of file objects that have been added to the directory since the last call to snapshot
     * @throws DataProcessorException if the workflow is executing on a node that does not allow file system access.
     */
    public Collection<File> snapshot() throws DataProcessorException {
        File workingDir = getWorkingDirectory();
        Collection<File> newFiles = new TreeSet<>();

        File[] children = workingDir.listFiles();
        if (children != null) {
            for (File child : children) {
                if (!existingFiles.contains(child)) {
                    newFiles.add(child);
                    existingFiles.add(child);
                }
            }
        }

        return newFiles;
    }
    
    /** Propagate metadata from inputs to output depending on what the metadata 
     * propagation setting is */
    public void propagateMetadata() throws DataProcessorException {
        if(getCallMessage().getMetadataPropagationMode().equals(DataProcessorServiceDefinition.META_DATA_DEFAULT_PROPAGATION) || getCallMessage().getMetadataPropagationMode().equals(DataProcessorServiceDefinition.META_DATA_REMOVE_DUPLICATES)){
            // Need to propagate metadata
            MetadataCollection metadataToPropagate = null;
            
            // Display metadata strategy
            if(getCallMessage().getMetadataPropagationMode().equals(DataProcessorServiceDefinition.META_DATA_DEFAULT_PROPAGATION)){
                System.out.println("Default metadata propagation");
            } else {
                System.out.println("No duplicates metadata propagation");
            }
            
            // Collect the correct set of metadata
            Enumeration<InputTransferDataHolder> inputs = inputDataTransferObjects.elements();
            InputTransferDataHolder input;
            while(inputs.hasMoreElements()){
                input = inputs.nextElement();
                if(input.getMetadata()!=null){
                    if(metadataToPropagate==null){
                        metadataToPropagate = input.getMetadata().getCopy();
                    } else {
                        if(getCallMessage().getMetadataPropagationMode().equals(DataProcessorServiceDefinition.META_DATA_DEFAULT_PROPAGATION)){
                            metadataToPropagate.merge(input.getMetadata(), MetadataCollection.DuplicatePolicy.DUPLICATES_IGNORED);
                        } else {
                            metadataToPropagate.merge(input.getMetadata(), MetadataCollection.DuplicatePolicy.DUPLICATES_REMOVED);
                        }
                    }
                }
            }
            
            // Assign this to the outputs
            if(metadataToPropagate!=null){
                Enumeration<OutputTransferDataHolder> outputs = outputDataTranferObjects.elements();
                OutputTransferDataHolder output;
                while(outputs.hasMoreElements()){
                    output = outputs.nextElement();
                    output.setMetadata(metadataToPropagate.getCopy());
                }
            }
        } else {
            System.out.println("Not propagating metadata");
        }
    }


    /**
     * Creates a new empty directory in the specified directory, using the given
     * prefix and suffix strings to generate its name. This method is based on
     * {@link java.io.File#createTempFile(String, String, File) File.createTempFile} but
     * instead of a temporary file it attempts to create a directory.
     * 
     * @param prefix The prefix string to be used in generating the directory's name; must be at least three characters long
     * @param suffix The suffix string to be used in generating the directory's name; may be null, in which case the suffix ".tmp" will be used
     * @param directory The directory in which the directory is to be created, or null if the default temporary-file directory is to be used
     * @return
     * @throws IOException
     */
    public static File createTempDir(String prefix, String suffix, File directory)
    throws IOException
    {
        File f;
        do {
            f = File.createTempFile(prefix, suffix, directory);
            f.delete();
        } while (!f.mkdir());

        return f;
    }


    /**
     * This is a convenience method equivalent to calling
     * {@link #createTempFile(String, File, CreateOption) createTempFile(filePath, directory, CreateOption.AddNameSuffix}.
     * 
     * @param filePath Initial file path relative to the given directory where the file will be created.
     * @param directory The directory in which the file is to be created, or 
     * <code>null</code> if the default temporary-file directory is to be used (as defined by property <code>java.io.tmpdir</code>).
     * @return reference to the newly created file.
     * 
     * @throws IOException
     */
    public static File createTempFile(String filePath, File directory)
    throws IOException
    {
        return createTempFile(filePath, directory, CreateOption.AddNameSuffix);
    }

    public enum CreateOption {
        AddPrefix,
        AddSuffix,
        AddNameSuffix,
    }

    /**
     * <p>Creates a new empty file in the specified directory, using given 
     * <code>filePath</code> to generate its name.</p>
     * 
     * <p>This method is similar to {@link java.io.File#createTempFile(String, String, File) java.io.File.createTempFile} 
     * as it tries to create a new file only if it did not exist before the call. 
     * The difference from the original {@link java.io.File#createTempFile(String, String, File) java.io.File.createTempFile} 
     * is that this method:
     * <ol>
     * <li>Attempts to create a file with the name exactly as the name given in 
     * the <code>filePath</code> argument.</li>
     * <li>If the first attempt fails, it appends an increasing integer between 
     * the basename and extension of the file denoted by <code>filePath</code>.</li>
     * <li>The basename may be of any length; not like <code>prefix</code> in 
     * {@link java.io.File#createTempFile(String, String, File) java.io.File.createTempFile}.</li>
     * <li><code>filePath</code> can denote a subdirectory relative to the given
     * <code>directory</code>. For example, if <code>filePath</code> is 
     * <code>"subSubPath/file.txt"</code> and <code>directory</code> is <code>"topPath/subPath"</code>
     * then the method will attempt to create file with path <code>topPath/subPath/subSubPath/file.txt"</code>.</li>
     * </ol> 
     *
     * @param filePath Initial file path relative to the given directory
     * 
     * @param directory The directory in which the file is to be created, or 
     * <code>null</code> if the default temporary-file directory is to be used
     * @param createOption The way in which to resolve name conflicts. If file <code>name.txt</code> exists before the call to this operation:
     * <code>AddPrefix</code> will create file <code>1-name.txt</code>,
     * <code>AddSuffix</code> will create file <code>name.txt-1</code>,
     * <code>AddNameSuffix</code> will generate <code>name-1.txt</code>,
     * 
     * @return a file with a non-clashing filename.
     * 
     * @throws IOException If an I/O error occurs when creating a new file. 
     */
    public static File createTempFile(String filePath, File directory, CreateOption createOption)
    throws IOException
    {
        //File.createTempFile(prefix, suffix, null);
        // Try to create a file with the original fileName
        File f = new File(directory, filePath);

        if (!f.createNewFile()) {
            // If createNewFile failed, we attempt to create a file with an increasing 
            // integer appended according to the createOption

            if (CreateOption.AddPrefix.equals(createOption)) {
                // append prefix like 1-name.txt, 2-name.txt
                String fileName = f.getName();
                int i = 1;
                do {
                    f = new File(f.getParentFile(), (i++) + "-" + fileName);
                } while (!f.createNewFile());
            } else if (CreateOption.AddSuffix.equals(createOption)) {
                // append suffix like name.txt-1, name.txt-2
                String fileName = f.getPath();
                int i = 1;
                do {
                    f = new File(fileName + "-" + (i++));
                } while (!f.createNewFile());
            } else if (CreateOption.AddNameSuffix.equals(createOption)) {
                // append name suffix like name-1.txt, name-2.txt

                //Split the fileName on prefix and suffix
                String fileName = f.getName();
                int lastDot = fileName.lastIndexOf('.');

                String prefix, suffix;
                if (lastDot <= 0) {
                    // If lastDot is 0, the name is like '.filename'. Then the
                    // integer should be added to the end.
                    prefix = fileName;
                    suffix = "";
                } else {
                    prefix = fileName.substring(0, lastDot);
                    suffix = fileName.substring(lastDot);
                }

                int i = 1;
                do {
                    f = new File(f.getParentFile(), prefix + "-" + (i++) + suffix);
                } while (!f.createNewFile());
            } else {
                throw new IllegalArgumentException("Unsupported option: " + createOption);
            }
        }

        return f;
    }


    /** Create a data source client for a call message */
    private DataProcessorDataSource createSourceClient(DataProcessorCallMessage message) throws DataProcessorException {
        // Create the correct type of data client
        if (message.getDataTransferType().equals(DataProcessorDataSource.FILE_DATA_SOURCE)) {
            return new DataProcessorDataSourceFileClient(message.getStorageUrl());

        } else if (message.getDataTransferType().equals(DataProcessorDataSource.WEB_DATA_SOURCE)) {
            throw new DataProcessorException("Web client not implemented yet");
        } else {
            throw new DataProcessorException("Could not create data access client");
        }
    }
}
